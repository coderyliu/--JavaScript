# 深入JavaScript闭包

### 让人迷惑的闭包

闭包是JavaScript中一个非常容易让人迷惑的知识点： 

这几天看到有伙伴在交流群中发了这么一张图片； 

![image-20211213124711796](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20211213124711796.png)

闭包确实是JavaScript中一个很难理解的知识点，接下来我们就对其一步步来进行剖析，看看它到底有什么神奇之 

处。

### JS中函数是一等公民

- 在JavaScript中，函数是非常重要的，并且是一等公民： 
  - 那么就意味着函数的使用是非常灵活的；
  - 函数可以作为另外一个函数的参数，也可以作为另外一个函数的返回值来使用；
- 自己编写高阶函数
  - 自己编写的高阶函数指的就是这个函数既可以作为另一个函数的参数被使用，也可以作为另一个函数的返回值
- 使用内置的高阶函数
  - 常见的内置高阶函数有很多，比如filter、map、reduce等等

### JS中闭包的定义

这里先来看一下闭包的定义，分成两个：在计算机科学中和在JavaScript中。

- 在计算机科学中对闭包的定义（维基百科）：
  - 闭包（英语：Closure），又称**词法闭包**（Lexical Closure）或**函数闭包**（function closures）；
  - 是在支持 **头等函数** 的编程语言中，实现词法绑定的一种技术；
  - 闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）；
  - 闭包跟函数最大的区别在于，当捕捉闭包的时候，它的 **自由变量** 会在捕捉时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行；

- 闭包的概念出现于60年代，最早实现闭包的程序是 Scheme，那么我们就可以理解为什么JavaScript中有闭包：
  - 因为JavaScript中有大量的设计是来源于Scheme的；

- 我们再来看一下MDN对JavaScript闭包的解释：
  -  一个函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是**闭包**（**closure**）；
  - 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域；
  - 在 JavaScript 中，每当创建一个函数，闭包就会在函数创建的同时被创建出来；

- 那么我的理解和总结：
  - 一个普通的函数function，如果它可以访问外层作用于的自由变量，那么这个函数就是一个闭包；
  - 从广义的角度来说：JavaScript中的函数都是闭包；
  - 从狭义的角度来说：JavaScript中一个函数，如果访问了外层作用于的变量，那么它是一个闭包；

### 闭包的访问过程

如果我们编写了如下的代码，它一定是形成了闭包的：

![image-20211213135226500](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20211213135226500.png)

### 闭包的执行过程

那么函数继续执行呢？ 

这个时候makeAdder函数执行完毕，正常情况下我们的AO对象会被释放；

但是因为在0xb00的函数中有作用域引用指向了这个AO对象，所以它不会被释放掉；

![image-20211213135606161](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20211213135606161.png)

### 闭包的内存泄露

那么我们为什么经常会说闭包是有内存泄露的呢？ 

​	在上面的案例中，如果后续我们不再使用add10函数了，那么该函数对象应该要被销毁掉，并且其引用着的父 

作用域AO也应该被销毁掉；但是目前因为在全局作用域下add10变量对0xb00的函数对象有引用，而0xb00的作

用域中AO（0x200）有引用，所以最终会造成这些内存都是无法被释放的；所以我们经常说的闭包会造成内存泄露，其实就是刚才的引用链中的所有对象都是无法释放的；

那么，怎么解决这个问题呢？ 

​	因为当将add10设置为null时，就不再对函数对象0xb00有引用，那么对应的AO对象0x200也就不可达了；

在GC的下一次检测中，它们就会被销毁掉；

### 闭包的内存泄漏测试

![image-20211213135839041](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20211213135839041.png)

### AO不使用的属性

​	我们来研究一个问题：AO对象不会被销毁时，是否里面的所有属性都不会被释放？下面这段代码中name属于闭包的父作用域里面的变量；我们知道形成闭包之后count一定不会被销毁掉，那么name是否会被销毁掉呢？ 

​	这里我打上了断点，我们可以在浏览器上看看结果；

![image-20211213140002193](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20211213140002193.png)