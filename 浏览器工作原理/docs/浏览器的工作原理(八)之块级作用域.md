# 浏览器的工作原理(八)之块级作用域

​	在前面《 变量提升：JavaScript 代码是按顺序执行的吗？》这篇文章中，我们已经讲解了 JavaScript 中变量提

升的相关内容，正是由于 JavaScript 存在变量提升这种特性，从而导致了很多与直觉不符的代码，这也是 

JavaScript 的一个重要设计缺陷。

​	虽然 ECMAScript6（以下简称 ES6）已经通过引入块级作用域并配合 let、const 关键字，来避开了这种设计缺

陷，但是由于 **JavaScript 需要保持向下兼容**，所以变量提升在相当长一段时间内还会继续存在。这也加大了你理

解概念的难度，因为既要理解新的机制，又要理解变量提升这套机制，关键这两套机制还是同时运行在“一套”系统

中的。但如果抛开 JavaScript 的底层去理解这些，那么你大概率会很难深入理解其概念。俗话说，“断病要断因，

治病要治根”，所以为了便于你更好地理解和学习，今天我们这篇文章会先“探病因”——分析为什么在 JavaScript 

中会存在变量提升，以及变量提升所带来的问题；然后再来“开药方”——介绍如何通过块级作用域并配合 let 和 

const 关键字来修复这种缺陷。

### 作用域（scope）

​	为什么 JavaScript 中会存在变量提升这个特性，而其他语言似乎都没有这个特性呢？要讲清楚这个问题，我们

就得先从作用域讲起。作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域

就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

​	在 ES6 之前，ES 的作用域只有两种：**全局作用域和函数作用域**。全局作用域中的对象在代码中的任何地方都能

访问，其生命周期伴随着页面的生命周期。函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者

函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。在 ES6 之前，JavaScript 只支持

这两种作用域，相较而言，其他语言则都普遍支持块级作用域。块级作用域就是使用一对大括号包裹的一段代码，

比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。为了更好地理解块级作用

域，你可以参考下面的一些示例代码：

```jsx
//if块
if(1){}

//while块
while(1){}

//函数块
function foo(){}
 
//for循环块
for(let i = 0; i<100; i++){}

//单独一个块
{}
```

​	简单来讲，如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。

​	和 Java、C/C++ 不同，ES6 之前是不支持块级作用域的，因为当初设计这门语言的时候，并没有想到 JavaScript 会火起来，所以只是按照最简单的方式来设计。没有了块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。

### 变量提升所带来的问题

- 变量容易在不被察觉的情况下被覆盖掉
- 本应销毁的变量没有被销毁

### ES6 是如何解决变量提升带来的缺陷

​	上面我们介绍了变量提升而带来的一系列问题，为了解决这些问题，ES6 引入了 let 和 const 关键字，从而使 JavaScript 也能像其他语言一样拥有了块级作用域。关于 let 和 const 的用法，你可以参考下面代码：

```jsx
let x = 5
const y = 6
x = 7
y = 9 //报错，const声明的变量不可以修改
```

### JavaScript 是如何支持块级作用域的

​	现在你知道了 ES 可以通过使用 let 或者 const 关键字来实现块级作用域，不过你是否有过这样的疑问：“在同一段代码中，ES6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？”那么接下来，我们就要站在执行上下文的角度来揭开答案。你已经知道 JavaScript 引擎是通过变量环境实现函数级作用域的，那么 ES6 又是如何在函数级作用域的基础之上，实现对块级作用域的支持呢？你可以先看下面这段代码：

```jsx
function foo(){
    var a = 1
    let b = 2
    {
      let b = 3
      var c = 4
      let d = 5
      console.log(a)
      console.log(b)
    }
    console.log(b) 
    console.log(c)
    console.log(d)
}   
foo()
```

​	当执行上面这段代码的时候，**JavaScript 引擎会先对其进行编译并创建执行上下文**，然后再按照顺序执行代码，关于如何创建执行上下文我们在前面的文章中已经分析过了，但是现在的情况有点不一样，我们引入了 let 关键字，let 关键字会创建块级作用域，那么 let 关键字是如何影响执行上下文的呢？接下来我们就来一步步分析上面这段代码的执行流程。第一步是编译并创建执行上下文，下面是我画出来的执行上下文示意图，你可以参考下：

![image-20220503193646489](D:\截图\22_浏览器原理\image-20220503193646489.png)

​	通过上图，我们可以得出以下结论：

- **函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。**
- **通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。**
- **在函数的作用域块内部，通过 let 声明的变量并没有被存放到词法环境中。**

​	接下来，第二步继续执行代码，当执行到代码块里面时，变量环境中 a 的值已经被设置成了 1，词法环境中 b 的值已经被设置成了 2，这时候函数的执行上下文就如下图所示：

![image-20220503193841495](D:\截图\22_浏览器原理\image-20220503193841495.png)

​	从图中可以看出，当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。

​	**其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构**。

​	**需要注意下，我这里所讲的变量是指通过 let 或者 const 声明的变量。**再接下来，当执行到作用域块中的console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，**具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。**这样一个变量查找过程就完成了，你可以参考下图：

![image-20220503194039982](D:\截图\22_浏览器原理\image-20220503194039982.png)

​	从上图你可以清晰地看出变量查找流程，不过要完整理解查找变量或者查找函数的流程，就涉及到作用域链了，这个我们会在下篇文章中做详细介绍。**当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出**，最终执行上下文如下图所示：

![image-20220503194335629](D:\截图\22_浏览器原理\image-20220503194335629.png)

​	**块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。**

- var的创建和初始化被提升，赋值不会被提升。
- let的创建被提升，初始化和赋值不会被提升。 
- function的创建、初始化和赋值均会被提升。

​	**暂时性死去是语法规定的，也就是说虽然通过let声明的变量已经在词法环境中了，但是在没有赋值之前，访问该变量JavaScript引擎就会抛出一个错误。**